
## HW1

#### 1-1. 변수의 선언시 변수 영역에 식별자로 지정된 공간이 확보됨을 확인할 수 있다.

#### 1-2. 데이터가 데이터영역에 할당되면 데이터는 변수 영역 값이 가리키고있는 주소에 저장됨을 확인할 수 있다.

#### 1-3. 수, 문자열, boolean, Null, Undefined, Symbol은 불변값임을 확인할 수 있다.

#### 1-4. 참조형 데이터가 데이터 영역에 있다면 그 데이터가 가리키는 변수가 변함에 따라 그 값도 변화한다는 것을 확인할 수 있다.

#### 1-5. 참조형 데이터의 프로퍼티를 재할당할 경우 객체의 변수 영역이 가리키는 데이터 영역이 또한 변화하므로 변수 영역 값이 바뀐다는 것을 확인할 수 있다.

#### 1-6. 특정객체의 프로퍼티로 객체가 있는 경우 중첩 참조가 발생한다는 것을 확인할 수 있다.

#### 1-7. 두 변수에 복사가 일어났다면 두 변수는 같은 데이터 영역을 가리킨다는 것을 확인할 수 있다.

#### 1-8. 복사된 객체의 프로퍼티를 변경하더라도 변수가 가리키는 데이터 영역은 원본 객체와 같다는 것을 확인할 수 있다.

#### 1-9. 복사된 객체를 변경하면 원본 객체와 별개의 데이터 영역을 가리키게 된다는 것을 확인할 수 있다.

#### 1-10. 복사된 객체의 프로퍼티만을 수정하여, 원본 객체와 사본 객체가 가리키는 데이터 영역이 같아짐에 따라 원본 객체의 프로퍼티가 달라지는 문제가 발생한다는 것을 확인할 수 있다.

#### 1-11. 객체를 처음부터 다시 만들어 변수에 저장함으로써 문제를 해결할 수 있음을 확인할 수 있다.

#### 1-12. 객체의 얕은 복사를 수행을 확인할 수 있다.

#### 1-13. 예제 1-12에서 만든 객체 복사 함수를 이용해 객체를 복사하고, 불변성을 유지함을 확인할 수 있다.

#### 1-14. 중첩된 객체에 얕은 복사를 수행하면 객체 프로퍼티에 대해 원본의 불변성이 확보되지 않는다는 것을 확인할 수 있다.

#### 1-15. 깊은 복사는 객체 프로퍼티의 내부까지 복사해 원본 객체의 불변성을 유지한다는 것을 확인할 수 있다.

#### 1-16. 객체 프로퍼티에 대해 copyObjectDeep 함수를 재귀적으로 호출해 깊은 복사를 범용적으로 수행한다는 것을 확인할 수 있다.

#### 1-17. 예제 1-16의 깊은 복사의 결과를 확인할 수 있다.

#### 1-18. 객체 -> JSON 문법 -> 깊은 복사 -> 객체로 치환한다. 이때 함수는 JSON 문법으로 변경할 수 없어 복사 과정에서 무시됨을 확인할 수 있다.

#### 1-19. 다음의 세 가지 경우 undefined가 자동으로 부여된다는 것을 확인할 수 있다.
##### - 값을 대입하지 않은 변수에 접근하는 경우
##### - 존재하지 않는 프로퍼티에 접근하는 경우
##### - 함수의 반환값이 존재하지 않는 경우

#### 1-20. 배열의 undefined 요소와 비어있는 요소는 다르다는 것을 확인할 수 있다.

#### 1-21. 비어있는 요소는 배열 메서드의 순회 대상에서 제외된다는 것을 확인할 수 있다.

#### 1-22. typeof null이 object를 반환하는 버그가 있으므로 어떤 변수가 null인지 판별하기 위해선 일치 연산자를 사용해야 한다는 것을 알 수 있다.

#### 2-1. 함수를 이용해 실행 컨텍스트를 구성해보면서 콜 스택에 실행 컨텍스트가 쌓이는 순서를 확인해본다.

#### 2-2. 원본 코드의 출력을 확인해보면서 호이스팅의 개념에 대해서 확인해본다.

#### 2-3. 매개변수를 변수선언과 할당과 동일하다고 간주하여 변환한 코드를 출력해보면서 호이스팅의 개념에 대해서 확인해본다. 결과는 동일하다.

#### 2-4. 호이스팅을 마친 상태로 간주하여 변환한 코드를 출력해보면서 호이스팅의 개념에 대해서 확인해본다. 결과는 동일하다

#### 2-5. 원본코드의 출력을 예상하고 확인하면서 호이스팅의 개념을 복습한다.

#### 2-6. 호이스팅을 마친 상태로 간주하여 변환한 코드를 출력해보면서 호이스팅의 개념에 대해서 확인해본다. 결과는 동일하다 

#### 2-7. 함수 선언문(정의부만 존재)을 함수 표현식(function을 별도 변수에 할당)으로 바꾼 코드의 결과를 출력해보면서 호이스팅의 개념에 대해서 확인해본다. 결과는 동일하다.

#### 2-8. 함수 선언문과 익명 함수 표현식, 기명 함수표현식으로 정의된 세가지 방식을 확인하고, 예상대로 기명 함수인 d()는 외부에서 접근할 수 없어 오류를 일으키는 것을 확인해본다.

#### 2-9. 원본 코드의 출력을 확인해보면서 함수 선언문과 함수 표현식의 차이를 이해한다. sum은 정상적으로 3이 출력되나, 값이 할당되지않은 multiply는 에러 메시지가 출력된다.

#### 2-10. 호이스팅을 마친 상태로 간주하여 변환한 코드를 출력해보면서 호이스팅의 개념에 대해서 확인해본다. 결과는 동일하다.

#### 2-11. 같은 이름의 함수가 함수 선언문으로 추가되었을 때, 실제로 호출되는 함수는 마지막에 할당한 함수이다. 즉 코드의 앞부분에서 숫자를 반환하는 코드를 짰어도 문자열을 반환하는 함수만이 실제로 호출 될 수 있다. 함수 선언문으로 정의한다면, 이러한 전혀 예기치 못한 오작동이 에러메세지도 없이 발생할 수 있다.

#### 2-12. 함수 표현식으로 선언한다면, 만에 하나 전역공간에 같은 이름의 함수가 있어도, 예제 2-11과는 달리 에러메세지를 출력하여 현 코드에 문제가 있다는 사실을 바로 알 수 있다.

#### 2-13. 식별자 a에 접근하려고하지만, 활성화된 inner 컨텍스트의 environmentRecord 에서의 a는 undefined 상태이기에 undefined가 출력되고, 전역 lexicalEnvironment의 a값인 1과 전역 컨텍스트의 environmentRecord의 a값인 1이 출력된다.

#### 2-14. 크롬 브라우저에서의 개발자 도구 콘솔을 이용해 스코프를 확인해본다.

#### 2-15. inner 함수 내부에서 b변수를 호출하면 스코프에 b도 노출되는 것을 확인할 수 있다.

#### 2-16. debugger로 바꾸어 크롬 브라우저에서 스코프체인과 this 정보를 확인할 수 있다.

#### 3-1. this와 window가 브라우저 환경에서 같은 전역 객체를 참조함을 확인할 수 있다.

#### 3-2. Node.js 환경에서 this 와 global 이 같은 전역 객체를 참조함을 확인할 수 있다.

#### 3-3. 브라우저 환경에서 선언된 변수 a가 전역 객체 window 와 this에 속해있음을 확인할 수 있다.

#### 3-4. 브라우저 환경에서 전역 객체 window와 this의 프로퍼티로 변수 a와 b가 접근 및 수정 가능함을 확인할 수 있다.

#### 3-5. 브라우저 환경에서 var로 선언된 전역 변수는 delete로 삭제할 수 없으나, 직접 window 객체에 할당된 프로퍼티는 삭제할 수 있음을 확인할 수 있다.

#### 3-6. 함수가 일반적으로 호출될 때는 전역 객체를 this로 참조하고, 객체의 메소드로 호출될 때는 해당 객체를 this로 참조함을 확인할 수 있다.

#### 3-7. 객체 내부에서 메소드가 직접 호출되거나 대괄호 표기법으로 호출될 때, this는 해당 객체를 참조함을 확인할 수 있다

#### 3-8. 객체의 메소드가 직접 호출되거나 대괄호 표기법으로 호출될 때, this는 메소드가 정의된 현재 객체를 참조함을 확인할 수 있다.

#### 3-9. 함수 내에서 정의된 내부 함수는 기본적으로 전역 객체를 this로 참조하지만, 다른 객체에 할당되어 메소드로 호출될 경우 그 객체를 this로 참조하게 된다.

#### 3-10. 객체 메소드에서 일반 함수로 호출된 내부 함수는 전역 객체를 this로 참조하며, self 변수를 사용하여 내부 함수에서 외부 함수의 this를 참조할 수 있음을 확인할 수 있다.

#### 3-11. 객체의 메소드에서 화살표 함수로 정의된 내부 함수는 외부 함수와 같은 this 즉, 호출한 객체를 참조함을 확인할 수 있다.

#### 3-12. 브라우저 환경에서 setTimeout과 배열의 forEach 메소드 내의 일반 함수는 전역 객체 window를 this로 참조하며, 이벤트 핸들러 함수에서는 해당 핸들러가 부착된 요소를 this로 참조함을 확인할 수 있다.

#### 3-13. 생성자 함수 Cat을 사용하여 choco와 nabi 두 객체를 생성하고, 각 객체는 고유의 이름과 나이 속성을 가지며 공통적으로 '야옹'을 출력함을 확인할 수 있다.

#### 3-14. 일반적으로 호출된 함수는 전역 객체를 this로 참조하며, call 메소드를 사용하여 호출된 함수는 지정된 객체 { x: 1 }를 this로 참조하고 인자를 순서대로 전달받음을 확인할 수 있다.

#### 3-15. 객체의 메소드가 직접 호출될 때는 해당 객체의 프로퍼티 a를 참조하며, call 메소드를 사용하여 다른 객체로 this를 지정할 경우 지정된 객체의 프로퍼티 a와 주어진 인자들을 사용함을 확인할 수 있다.

#### 3-16. apply 메소드를 사용하여 함수나 메소드를 호출할 때, 첫 번째 인자로 전달한 객체가 this로 설정되며, 두 번째 인자로 전달한 배열은 함수나 메소드의 매개변수로 전달됨을 확인할 수 있다.

#### 3-17. 객체에 push 메소드를 호출하여 배열처럼 동작하도록 설정하고, 이후 slice 메소드를 사용하여 객체를 배열로 변환함을 확인할 수 있다

#### 3-18. 함수 a는 가변 인자를 배열로 변환하여 각 인자를 출력하고, DOM 요소들을 선택하여 배열로 변환한 후 각 요소를 출력함을 확인할 수 있다.

#### 3-19. 문자열을 배열 메소드를 사용하여 조작할 때, push 메소드는 길이를 변경할 수 없는 읽기 전용 속성에 할당할 수 없다는 오류가 발생하며, concat 메소드는 새로운 배열을 반환하고, every 메소드는 문자열 전체가 주어진 조건을 만족하지 않음을 확인했으며, some 메소드는 문자열 중 일부가 주어진 조건을 만족함을 확인할 수 있다. map 메소드는 각 문자에 대해 '!'를 추가한 새로운 배열을 반환하고, reduce 메소드는 문자열을 누적하여 새로운 문자열을 생성함을 확인할 수 있다.

#### 3-20. 객체를 배열로 변환할 때 Array.from 메소드를 사용하여 각 프로퍼티 값을 배열 요소로 가져왔음을 확인할 수 있다.

#### 3-21. Student와 Employee 생성자 내에서 Person 생성자를 호출할 때 call 및 apply 메서드를 활용한다. 이를 통해 Person의 프로퍼티와 메서드를 상속받고, 각각의 객체에 새로운 속성을 추가한다. 최종적으로 Student와 Employee 객체를 생성함을 확인할 수 있다.

#### 3-22. 주어진 배열에서 최댓값과 최솟값을 찾아 출력함을 확인할 수 있다.

#### 3-23. 주어진 배열에서 가장 큰 수와 가장 작은 수를 각각 찾아내어 출력함을 확인할 수 있다. Math 객체의 max 및 min 메서드를 사용하여 각각 최댓값과 최솟값을 이전보다 쉽게 구할 수 있었다.

#### 3-24. 주어진 배열에서 가장 큰 수와 가장 작은 수를 각각 찾아내어 출력함을 확인할 수 있다. 펼치기 구문을 사용하여 Math 객체의 max 및 min 메서드를 간결하게 적용했다.

#### 3-25. 함수 func를 생성한 후, bind 메소드를 사용하여 다른 객체와 바인딩된 새로운 함수를 생성하고 호출했다. bind 메소드를 사용하여 함수에 추가적으로 인자를 전달하면 해당 인자가 바인딩된 함수의 매개변수로 사용된다.

#### 3-26. bind 메소드로 생성된 새로운 함수의 name 속성은 원본 함수의 이름을 유지한다.

#### 3-27. 객체의 메소드 내에서 내부 함수를 호출할 때, call 메소드를 사용하여 외부 함수의 this를 전달하거나, 내부 함수를 생성할 때 bind 메소드를 사용하여 외부 함수의 this를 유지함을 확인할 수 있다.

#### 3-28. setTimeout 함수 내에서 메소드를 호출할 때, 바로 호출한 경우와 bind 메소드를 사용하여 호출한 경우에는 this의 참조가 다르게 되어 결과가 달라짐을 확인할 수 있다.

#### 3-29. 화살표 함수 내에서 this는 상위 스코프의 this를 유지함을 확인할 수 있다. 객체의 메소드에서 화살표 함수를 사용하면 메소드가 호출된 객체를 this로 참조한다.

#### 3-30. 메소드 add를 사용하여 sum과 count를 업데이트하고, average 메소드를 사용하여 sum을 count로 나눈 평균을 계산함을 확인할 수 있다.

#### 3-31. 여러 메소드에서 자주 사용되는 배열 및 집합과 관련된 메소드들이다. 이 메소드들은 배열 또는 집합을 순회하거나 조작할 때 유용하게 사용된다. 메소드 호출 시 각각의 메소드가 받는 매개변수와 동작에 대한 설명이 포함되어 있다. 각 메소드는 주어진 콜백 함수를 배열 또는 집합의 각 요소에 적용하며, 선택적으로 콜백 함수 내에서 사용될 this 값도 지정할 수 있다.


## HW2

#### 4-1. setInterval 함수에 익명 함수와 숫자를 인자로 전달하였다.

#### 4-2 4-1에서 사용한 익명 함수를 cbFunc라는 이름으로 명시적으로 정의하고 이를 setInterval의 인자로 전달하였다.

#### 4-3 배열의 map 메서드를 호출하면서 첫 번째 인자로 익명 함수를 전달하였다.

#### 4-4 배열 메서드의 인자를 jQuery 스타일로 순서를 바꾸어 전달하였다.

#### 4-5 배열의 map 메서드를 구현하였다.

#### 4-6 제어권을 넘겨받는 코드에서 call/apply 메서드를 사용하여 첫 번째 인자로 콜백 함수 내부의 this가 될 객체를 명시적으로 바인딩하였다.

#### 4-7 콜백 함수로 객체의 메서드를 전달할 경우, 해당 메서드는 메서드가 아닌 일반 함수로 호출된다.

#### 4-8 this를 다른 변수에 할당한 뒤, 이를 콜백 함수 내에서 사용하여 클로저로 만들었다.

#### 4-9 4-8에서 this를 사용하지 않았기 때문에, 해당 함수를 this를 이용해 재사용할 수 없는 단점이 있다.

#### 4-10 4-8의 함수를 실행한 결과를 콜백으로 사용하였다.

#### 4-11 bind 메서드를 사용하여 4-8 방식의 메모리 낭비 문제를 개선하였다.

#### 4-12 콜백 지옥은 익명 콜백 함수를 반복적으로 사용하여 코드의 들여쓰기가 과도하게 깊어지는 현상이다.

#### 4-13 익명 콜백 함수를 모두 기명 함수로 변경하여 콜백 지옥 문제를 해결하였다.

#### 4-14 ES6의 Promise를 사용하여 비동기 작업을 동기식 코드처럼 표현하였다.

#### 4-15 4-14의 반복되는 코드를 함수로 추출하여 간결하게 표현하였다.

#### 4-16 ES6의 Generator를 사용하여 비동기 작업을 동기적으로 표현하였다.

#### 4-17 ES2017에 도입된 async/await을 사용하여 비동기 작업을 더 간단하게 표현하였다.

#### 5-1 내부 함수 inner는 외부 함수 outer의 변수 a에 접근하여 그 값을 증가시키고 출력한다.

#### 5-2 외부 함수 outer는 내부 함수 inner를 호출하여 변수 a를 증가시키고 그 값을 반환하며, outer2는 증가된 값을 출력한다.

#### 5-3 외부 함수 outer는 내부 함수 inner를 반환하고, outer2는 inner를 참조하여 호출될 때마다 변수 a를 증가시키고 그 값을 출력한다.

#### 5-4 즉시 실행 함수 내에서 클로저를 사용하여 setInterval과 버튼 클릭 이벤트 핸들러가 각각 변수 a와 count를 증가시키고 출력한다.

#### 5-5 클로저를 사용하여 내부 상태를 관리하며, 각 실행 컨텍스트에서 변수를 증가시키고 조건에 따라 참조를 해제한다.

#### 5-6 클로저를 사용하여 각 리스트 아이템을 클릭할 때 해당 과일 이름을 알림으로 표시한다.

#### 5-7 리스트 아이템을 클릭하면 클로저를 사용하여 각 과일 이름을 알림으로 표시하고, alertFruit 함수를 직접 호출하여 특정 과일을 알림으로 표시한다.

#### 5-8 bind 메서드를 사용하여 클릭 이벤트 핸들러에서 각 과일 이름을 알림으로 표시하도록 클로저를 생성한다.

#### 5-9 클로저를 반환하는 alertFruitBuilder 함수를 사용하여 클릭 이벤트 핸들러에서 각 과일 이름을 알림으로 표시한다.

#### 5-10 car 객체는 연료량, 출력, 이동 거리 속성을 가지고 있으며, run 메서드를 통해 임의의 거리를 이동하고 연료를 소비하며, 연료가 부족하면 이동 불가 메시지를 출력한다.

#### 5-11 createCar 함수는 클로저를 사용하여 연료량, 출력, 이동 거리 속성을 캡슐화하고, run 메서드를 통해 임의의 거리를 이동하며 연료를 소비하고, 이동할 수 없을 때 메시지를 출력하는 car 객체를 생성한다.

#### 5-12 createCar 함수는 클로저를 사용하여 연료량, 출력, 이동 거리 속성을 캡슐화하고, Object.freeze를 사용해 반환된 객체의 변경을 막으며, run 메서드를 통해 임의의 거리를 이동하고 연료를 소비하는 car 객체를 생성한다.

#### 5-13 add 함수는 모든 인수의 합을 반환하며, add.bind(null, 1, 2, 3, 4, 5)는 부분 적용을 통해 초기 인수로 1, 2, 3, 4, 5를 고정하고, 추가 인수로 6, 7, 8, 9, 10을 받아 전체 합을 계산하여 출력한다.

#### 5-14 partial 함수는 부분 적용 함수로, 초기 인수와 추가 인수를 결합하여 원래 함수를 호출한다. 이를 통해 addPartial은 초기 인수 1, 2, 3, 4, 5와 추가 인수 6, 7, 8, 9, 10을 합산하고, dog.greet는 dog 객체의 name 속성을 사용하여 문자열을 반환한다.

#### 5-15 partial2 함수는 _를 자리 표시자로 사용하는 부분 적용 함수로, 부분 인수에서 _를 만나면 이후 인수로 대체한다. 이를 통해 addPartial은 지정된 위치에 새로운 값을 삽입하여 전체 합을 계산하고, dog.greet는 자리 표시자를 사용하여 문자열을 반환한다.

#### 5-16 debounce 함수는 이벤트 발생 후 일정 시간 동안 추가 이벤트가 발생하지 않을 때만 실행되는 함수를 반환하여, mousemove와 mousewheel 이벤트에 대해 설정된 지연 시간 후에 각각 moveHandler와 wheelHandler를 호출한다.

#### 5-17 curry3 함수는 인수를 하나씩 받아 최종적으로 두 인수를 가진 함수를 반환한다. 이를 통해 getMaxWith10은 10과 주어진 인수 중 더 큰 값을 반환하고, getMinWith10은 10과 주어진 인수 중 더 작은 값을 반환한다.

#### 5-18 curry5 함수는 인수를 하나씩 받아 최종적으로 다섯 인수를 가진 함수를 반환한다. 이를 통해 getMax는 다섯 인수를 받아 그 중 가장 큰 값을 반환한다.


## HW3

#### 6-1 Person 생성자 함수와 getName 메서드를 정의하여 이름을 관리하고 반환할 수 있도록 구현하였다.

#### 6-2 Constructor 생성자 함수와 프로토타입 속성 및 메서드를 정의하고, 해당 생성자로부터 인스턴스를 생성하여 출력하였다.

#### 6-3 배열의 생성자 속성을 이용해 새로운 배열을 생성하고 출력하였다.

#### 6-4 dataTypes 배열의 각 요소의 생성자를 NewConstructor로 변경하고, 각 요소의 생성자 이름과 NewConstructor의 인스턴스 여부를 출력하였다.

#### 6-5 Person 생성자 함수로부터 여러 인스턴스를 다양한 방법으로 생성하고, 각 인스턴스와 Person의 인스턴스 여부를 출력하였다.

#### 6-6 Person 생성자 함수와 getName 메서드를 정의하고, 인스턴스 iu의 getName 메서드를 재정의하여 출력하였다.

#### 6-7 배열 arr에 push 메서드를 사용하여 요소를 추가한 후, 추가된 요소의 인덱스가 배열의 고유 속성인지 확인하였다.

#### 6-8 배열 arr의 toString 메서드를 재정의하여 _로 구분된 문자열로 반환하도록 하고, 이를 호출하여 출력하였다.

#### 6-9 Object.prototype.getEntries 메서드를 정의하여 객체의 속성과 값을 [키, 값] 형태의 배열로 반환하고, 주어진 데이터 배열의 각 요소에 대해 해당 메서드를 호출하여 결과를 출력하였다.

#### 6-10 Grade 생성자 함수는 주어진 인자들을 배열로 변환하여 각 인자를 인덱스로 갖는 속성을 생성하고, 배열의 길이를 설정하여 인스턴스를 생성한다.

#### 7-1 Rectangle을 정의하고, 넓이를 계산하는 getArea 메서드와 인스턴스가 Rectangle 클래스의 인스턴스인지 확인하는 isRectangle 메서드를 추가한다. 그리고 Rectangle 클래스의 인스턴스를 생성하여 넓이를 출력하고, 클래스 메서드를 호출하여 해당 인스턴스가 Rectangle인지 확인한다.

#### 7-2 배열과 유사한 Grade 클래스를 정의하고 인스턴스를 생성한다. Grade 클래스는 생성자 함수를 통해 인자를 받아 인스턴스를 초기화하고, 이 인스턴스는 배열과 유사하게 동작한다.

#### 7-3 Grade 클래스를 정의하고 인스턴스를 생성하여 배열과 유사하게 동작하는 것을 보여준다. 처음에는 인스턴스의 길이가 올바르게 설정되지만, delete 연산자로 length 속성을 삭제하면서 인스턴스의 길이가 변경된다.

#### 7-4  Grade 클래스를 정의하고 인스턴스를 생성하여 배열과 유사하게 동작하는 것을 보여준다. Grade.prototype을 배열로 설정하면서 프로토타입에 초기 요소를 설정한다. 그러나 g.push(90)과 같이 값을 추가할 때마다 인스턴스에 직접 속성을 추가하므로 length 속성이 변경되지 않는다. 따라서 delete g.length 후에 g.push(70)을 호출하면 인스턴스의 길이가 증가한다.

#### 7-5 직사각형과 정사각형 클래스를 정의하고, 각각의 넓이를 계산하는 메서드를 추가하여 사용한다.

#### 7-6 직사각형과 정사각형 클래스를 정의하고, 각각의 넓이를 계산하는 메서드를 추가헤 사용한다.

#### 7-7 직사각형과 정사각형 클래스를 정의하고, 직사각형 클래스의 인스턴스를 상속해 정사각형 클래스를 만들어 넓이를 계산합니다.

#### 7-8 클래스 상속을 구현하기 위해 extendClass1 함수를 사용하여 직사각형 클래스를 상속하는 정사각형 클래스를 만든다. 정사각형 클래스는 직사각형 클래스의 생성자를 호출하며 한 변의 길이를 초기화한다.

#### 7-9 클로저를 사용하여 클래스 상속을 구현하는 extendClass2 함수를 정의한다. 이 함수는 직사각형 클래스를 상속하는 정사각형 클래스를 만든다. 클로저 내부에 Bridge라는 빈 함수를 정의하여 중간 다리 역할을 수행하게한다.

#### 7-10 직사각형 클래스를 정의하고, 정사각형 클래스를 직사각형 클래스를 상속하여 만든다. 따라서 정사각형 클래스는 직사각형 클래스를 상속하고, 정사각형의 넓이를 계산한다.

#### 7-11 클래스 상속을 구현하는 extendClass1 함수를 정의한다. 부모 클래스를 상속하는 자식 클래스를 만드는데, 부모 클래스의 인스턴스를 자식 클래스의 프로토타입으로 설정한 후, 자식 클래스의 프로토타입을 순회하면서 부모 클래스의 메서드를 삭제한다. 그리고 자식 클래스의 생성자를 설정하고, 필요한 경우 자식 클래스에 메서드를 추가한다. 마지막으로 자식 클래스의 프로토타입을 동결해 변경을 막는다.

#### 7-12 클로저를 사용하여 클래스 상속을 구현하는 extendClass2 함수를 정의한다. 내부적으로 Bridge라는 빈 함수를 사용하여 부모 클래스와 자식 클래스의 프로토타입을 연결한다. 필요한 경우 자식 클래스에 메서드를 추가하고, 프로토타입을 동결하여 변경을 막는다.

#### 7-13 클래스 상속을 구현하는 extendClass3 함수를 정의한다. Object.create()를 사용하여 부모 클래스의 프로토타입을 상속하여 자식 클래스의 프로토타입을 만든 후, 필요한 경우 자식 클래스에 메서드를 추가하고, 프로토타입을 동결하여 변경을 막는다.

#### 7-14 클래스 상속을 구현하는 extendClass 함수를 정의한다. 부모 클래스의 프로토타입을 상속하여 자식 클래스의 프로토타입을 만들고, 필요한 경우 자식 클래스에 메서드를 추가합니다. 또한, super 메서드를 사용하여 부모 클래스의 메서드를 호출할 수 있도록 확장했다.

#### 7-15 ES5와 ES6 클래스를 정의하고 해당 클래스의 정적 메서드와 인스턴스 메서드를 호출한다. ES5에서는 함수 표현식을 사용하여 클래스를 정의하고, 정적 메서드와 프로토타입 메서드를 추가하는 반면, ES6에서는 클래스 선언을 사용하여 클래스를 정의하고, 정적 메서드와 인스턴스 메서드를 추가한다.

#### 7-16 ES6의 클래스와 클래스 상속을 사용하여 직사각형(Rectangle)과 정사각형(Square) 클래스를 정의한다.


